---
alwaysApply: true
---
TypeScript Implementation

- Enable strict mode
- Define clear interfaces for component props, state, and Redux state
  structure.
- Use type guards to handle potential undefined or null values safely.
- Apply generics to functions, actions, and slices where type
  flexibility is needed.
- Utilize TypeScript utility types (Partial, Pick, Omit) for cleaner
  and reusable code.
- Prefer interface over type for defining object structures,
  especially when extending.
- Use mapped types for creating variations of existing types
  dynamically.
- Always specify an explicit return type for functions and components.
- Avoid using the any type.

Type Safety Practices
- Prefer discriminated unions over enums when modeling variants and
  states.
- Use unknown instead of any for unchecked inputs; validate and narrow
  before use.
- Enforce exhaustive checks with `never` in switch statements to catch
  unhandled cases at compile time.
- Mark data as readonly where immutability is expected (props, DTOs,
  collections).
- Use `satisfies` to keep literal inference while ensuring objects meet
  required shapes without widening.
- Prefer `keyof typeof`/template literal types to keep keys aligned
  with runtime objects and reduce stringly-typed code.
